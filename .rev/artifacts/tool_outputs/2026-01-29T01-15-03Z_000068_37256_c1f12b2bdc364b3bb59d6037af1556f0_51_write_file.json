{
  "schema_version": "tool_output@1",
  "created_at": "2026-01-29T01:15:03Z",
  "tool": "write_file",
  "agent_name": "CodeWriterAgent",
  "session_id": "c1f12b2bdc364b3bb59d6037af1556f0",
  "task_id": "51",
  "step_id": 51,
  "tool_args": {
    "path": "gateway/src/routes/dashboard.test.ts",
    "content": "import { describe, it, expect, beforeAll, beforeEach, afterEach, vi } from 'vitest';\nimport { FastifyInstance } from 'fastify';\nimport { buildServer } from '../server.js';\nimport { db } from '../services/database.js';\nimport { config } from '../config.js';\n\ndescribe('Dashboard Routes', () => {\n  let server: FastifyInstance;\n  let testUserId: string;\n  let authHeader: string;\n\n  beforeAll(async () => {\n    // Initialize test configuration\n    config.jwtSecret = 'test-secret-for-dashboard-tests';\n    config.database.url = 'sqlite::memory:';\n    \n    // Mock database methods\n    vi.mock('../services/database.js', () => ({\n      db: {\n        query: vi.fn(),\n        execute: vi.fn(),\n        select: vi.fn(),\n        insert: vi.fn(),\n        update: vi.fn(),\n        delete: vi.fn(),\n      }\n    }));\n  });\n\n  beforeEach(async () => {\n    server = await buildServer();\n    await server.ready();\n    \n    testUserId = 'test-user-' + Date.now();\n    authHeader = `Bearer ${Buffer.from(JSON.stringify({ userId: testUserId })).toString('base64')}`;\n    \n    // Reset mocks\n    vi.clearAllMocks();\n  });\n\n  afterEach(async () => {\n    await server.close();\n  });\n\n  describe('GET /api/dashboard', () => {\n    it('should return dashboard data with valid authentication', async () => {\n      const mockDashboardData = {\n        totalRuns: 42,\n        activeRuns: 5,\n        completedRuns: 35,\n        failedRuns: 2,\n        totalModels: 10,\n        activeModels: 8,\n        recentRuns: [\n          { id: 'run-1', status: 'completed', model: 'gpt-4', createdAt: new Date().toISOString() },\n          { id: 'run-2', status: 'running', model: 'claude-3', createdAt: new Date().toISOString() },\n        ],\n        systemStats: {\n          cpuUsage: 45.5,\n          memoryUsage: 67.2,\n          uptime: 86400,\n        }\n      };\n\n      vi.mocked(db.query).mockResolvedValueOnce(mockDashboardData);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const payload = JSON.parse(response.payload);\n      expect(payload).toHaveProperty('success', true);\n      expect(payload.data).toEqual(mockDashboardData);\n      expect(payload).toHaveProperty('timestamp');\n    });\n\n    it('should return 401 without authentication', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard',\n      });\n\n      expect(response.statusCode).toBe(401);\n      const payload = JSON.parse(response.payload);\n      expect(payload).toHaveProperty('success', false);\n      expect(payload).toHaveProperty('error');\n    });\n\n    it('should return 401 with invalid authentication token', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard',\n        headers: {\n          authorization: 'Bearer invalid-token',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n      const payload = JSON.parse(response.payload);\n      expect(payload).toHaveProperty('success', false);\n    });\n\n    it('should handle database errors gracefully', async () => {\n      vi.mocked(db.query).mockRejectedValueOnce(new Error('Database connection failed'));\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      expect(response.statusCode).toBe(500);\n      const payload = JSON.parse(response.payload);\n      expect(payload).toHaveProperty('success', false);\n      expect(payload.error).toContain('Database');\n    });\n\n    it('should cache dashboard data for subsequent requests', async () => {\n      const mockDashboardData = { totalRuns: 42, activeRuns: 5 };\n      vi.mocked(db.query).mockResolvedValueOnce(mockDashboardData);\n\n      const response1 = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      const response2 = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      expect(response1.statusCode).toBe(200);\n      expect(response2.statusCode).toBe(200);\n      expect(db.query).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('GET /api/dashboard/stats', () => {\n    it('should return system statistics', async () => {\n      const mockStats = {\n        totalUsers: 150,\n        activeUsers: 45,\n        totalRequests: 5000,\n        requestsToday: 320,\n        avgResponseTime: 245,\n        successRate: 98.5,\n      };\n\n      vi.mocked(db.query).mockResolvedValueOnce(mockStats);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/stats',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const payload = JSON.parse(response.payload);\n      expect(payload).toHaveProperty('success', true);\n      expect(payload.data).toEqual(mockStats);\n    });\n\n    it('should support time range filtering', async () => {\n      const mockStats = { totalRequests: 100, avgResponseTime: 200 };\n      vi.mocked(db.query).mockResolvedValueOnce(mockStats);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/stats?range=7d',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      expect(db.query).toHaveBeenCalledWith(\n        expect.objectContaining({\n          range: '7d'\n        })\n      );\n    });\n\n    it('should validate time range parameter', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/stats?range=invalid',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n      const payload = JSON.parse(response.payload);\n      expect(payload).toHaveProperty('success', false);\n    });\n\n    it('should require authentication', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/stats',\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n  });\n\n  describe('GET /api/dashboard/activity', () => {\n    it('should return recent activity logs', async () => {\n      const mockActivity = [\n        { id: 'act-1', type: 'run_created', userId: testUserId, timestamp: new Date().toISOString() },\n        { id: 'act-2', type: 'model_deployed', userId: 'user-2', timestamp: new Date().toISOString() },\n      ];\n\n      vi.mocked(db.query).mockResolvedValueOnce(mockActivity);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/activity',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const payload = JSON.parse(response.payload);\n      expect(payload).toHaveProperty('success', true);\n      expect(payload.data).toEqual(mockActivity);\n    });\n\n    it('should support pagination', async () => {\n      const mockActivity = [{ id: 'act-1', type: 'run_created' }];\n      vi.mocked(db.query).mockResolvedValueOnce(mockActivity);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/activity?page=1&limit=10',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      expect(db.query).toHaveBeenCalledWith(\n        expect.objectContaining({\n          page: 1,\n          limit: 10\n        })\n      );\n    });\n\n    it('should validate pagination parameters', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/activity?page=-1&limit=0',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n      const payload = JSON.parse(response.payload);\n      expect(payload).toHaveProperty('success', false);\n    });\n\n    it('should support activity type filtering', async () => {\n      const mockActivity = [{ id: 'act-1', type: 'run_created' }];\n      vi.mocked(db.query).mockResolvedValueOnce(mockActivity);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/activity?type=run_created',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n    });\n\n    it('should require authentication', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/activity',\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n  });\n\n  describe('GET /api/dashboard/health', () => {\n    it('should return system health status', async () => {\n      const mockHealth = {\n        status: 'healthy',\n        database: 'connected',\n        cache: 'connected',\n        services: {\n          auth: 'up',\n          models: 'up',\n          runs: 'up',\n        },\n        version: '1.0.0',\n      };\n\n      vi.mocked(db.query).mockResolvedValueOnce(mockHealth);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/health',\n      });\n\n      expect(response.statusCode).toBe(200);\n      const payload = JSON.parse(response.payload);\n      expect(payload).toHaveProperty('success', true);\n      expect(payload.data).toEqual(mockHealth);\n    });\n\n    it('should not require authentication', async () => {\n      const mockHealth = { status: 'healthy' };\n      vi.mocked(db.query).mockResolvedValueOnce(mockHealth);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/health',\n      });\n\n      expect(response.statusCode).toBe(200);\n    });\n\n    it('should report degraded status when services are down', async () => {\n      const mockHealth = {\n        status: 'degraded',\n        database: 'connected',\n        cache: 'disconnected',\n        services: {\n          auth: 'up',\n          models: 'down',\n          runs: 'up',\n        },\n      };\n\n      vi.mocked(db.query).mockResolvedValueOnce(mockHealth);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/health',\n      });\n\n      expect(response.statusCode).toBe(200);\n      const payload = JSON.parse(response.payload);\n      expect(payload.data.status).toBe('degraded');\n    });\n\n    it('should report unhealthy status when critical services fail', async () => {\n      const mockHealth = {\n        status: 'unhealthy',\n        database: 'disconnected',\n        services: {\n          auth: 'down',\n        },\n      };\n\n      vi.mocked(db.query).mockResolvedValueOnce(mockHealth);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/health',\n      });\n\n      expect(response.statusCode).toBe(503);\n      const payload = JSON.parse(response.payload);\n      expect(payload.data.status).toBe('unhealthy');\n    });\n  });\n\n  describe('GET /api/dashboard/metrics', () => {\n    it('should return performance metrics', async () => {\n      const mockMetrics = {\n        requestsPerMinute: 15.5,\n        avgLatency: 125,\n        p50Latency: 100,\n        p95Latency: 250,\n        p99Latency: 500,\n        errorRate: 0.5,\n      };\n\n      vi.mocked(db.query).mockResolvedValueOnce(mockMetrics);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/metrics',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const payload = JSON.parse(response.payload);\n      expect(payload).toHaveProperty('success', true);\n      expect(payload.data).toEqual(mockMetrics);\n    });\n\n    it('should support custom time windows', async () => {\n      const mockMetrics = { requestsPerMinute: 10 };\n      vi.mocked(db.query).mockResolvedValueOnce(mockMetrics);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/metrics?window=5m',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n    });\n\n    it('should validate time window parameter', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/metrics?window=invalid',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n    });\n\n    it('should require authentication', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard/metrics',\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n  });\n\n  describe('Rate Limiting', () => {\n    it('should enforce rate limits on dashboard endpoints', async () => {\n      const mockDashboardData = { totalRuns: 42 };\n      vi.mocked(db.query).mockResolvedValue(mockDashboardData);\n\n      // Make multiple rapid requests\n      const requests = Array(20).fill(null).map(() =>\n        server.inject({\n          method: 'GET',\n          url: '/api/dashboard',\n          headers: {\n            authorization: authHeader,\n          },\n        })\n      );\n\n      const responses = await Promise.all(requests);\n      const rateLimitedResponses = responses.filter(r => r.statusCode === 429);\n\n      expect(rateLimitedResponses.length).toBeGreaterThan(0);\n    });\n\n    it('should include rate limit headers in response', async () => {\n      const mockDashboardData = { totalRuns: 42 };\n      vi.mocked(db.query).mockResolvedValueOnce(mockDashboardData);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      expect(response.headers).toHaveProperty('x-ratelimit-limit');\n      expect(response.headers).toHaveProperty('x-ratelimit-remaining');\n      expect(response.headers).toHaveProperty('x-ratelimit-reset');\n    });\n  });\n\n  describe('Response Format', () => {\n    it('should return consistent response structure', async () => {\n      const mockDashboardData = { totalRuns: 42 };\n      vi.mocked(db.query).mockResolvedValueOnce(mockDashboardData);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      const payload = JSON.parse(response.payload);\n      \n      expect(payload).toHaveProperty('success');\n      expect(payload).toHaveProperty('data');\n      expect(payload).toHaveProperty('timestamp');\n      expect(typeof payload.success).toBe('boolean');\n      expect(typeof payload.timestamp).toBe('string');\n    });\n\n    it('should include proper content-type header', async () => {\n      const mockDashboardData = { totalRuns: 42 };\n      vi.mocked(db.query).mockResolvedValueOnce(mockDashboardData);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      expect(response.headers['content-type']).toContain('application/json');\n    });\n\n    it('should format error responses consistently', async () => {\n      vi.mocked(db.query).mockRejectedValueOnce(new Error('Test error'));\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/dashboard',\n        headers: {\n          authorization: authHeader,\n        },\n      });\n\n      const payload = JSON.parse(response.payload);\n      \n      expect(payload).toHaveProperty('success', false);\n      expect(payload).toHaveProperty('error');\n      expect(payload).toHaveProperty('timestamp');\n      expect(typeof payload.error).toBe('string');\n    });\n  });\n});"
  },
  "tool_args_digest": "f2cb21a887297ebc1985756f663ffba3fccb09bd19aacf57e77a3d8d538bb616",
  "content_type": "text/plain",
  "output": "{\"wrote\": \"gateway\\\\src\\\\routes\\\\dashboard.test.ts\", \"bytes\": 15983, \"path_abs\": \"C:\\\\Users\\\\TimShelton\\\\source\\\\repos\\\\AiRemoteCoder\\\\gateway\\\\src\\\\routes\\\\dashboard.test.ts\", \"path_rel\": \"gateway/src/routes/dashboard.test.ts\"}",
  "redacted": false,
  "redaction_rules_version": 1,
  "output_digest_raw": "7bc44d24eb99763d958e12da5147608280a53b934519ec0fd99c85a498e7c2ac",
  "output_digest_redacted": "3f441fff079c44cd3395eeae08138ec6a223fc935125d066cf5e9dcf38394c67",
  "truncated": false,
  "byte_len": 228,
  "line_count": 1
}