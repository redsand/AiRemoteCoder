{
  "schema_version": "tool_output@1",
  "created_at": "2026-01-29T01:16:17Z",
  "tool": "read_file",
  "agent_name": "ResearchAgent",
  "session_id": "c1f12b2bdc364b3bb59d6037af1556f0",
  "task_id": "53",
  "step_id": 53,
  "tool_args": {
    "path": "gateway/src/routes/models.ts"
  },
  "tool_args_digest": "c31432d22afe8575a194184faf8743548b453ee08f5081ac48def6bd999355e6",
  "content_type": "text/plain",
  "output": "import type { FastifyInstance } from 'fastify';\nimport { config } from '../config.js';\n\ninterface ModelOption {\n  value: string;\n  label: string;\n}\n\ninterface ModelsResponse {\n  provider: string;\n  models: ModelOption[];\n  available: boolean;\n  error?: string;\n}\n\n\n/**\n * Query Claude API for available models\n */\nasync function getClaudeModels(): Promise<ModelOption[]> {\n  try {\n    const apiKey=[REDACTED]\n    if (!apiKey) {\n      return [];\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 5000);\n\n    const response = await fetch('https://api.anthropic.com/v1/models', {\n      headers: {\n        'x-api-key': apiKey,\n        'anthropic-version': '2023-06-01',\n      },\n      signal: controller.signal,\n    });\n    clearTimeout(timeoutId);\n\n    if (!response.ok) {\n      console.warn(`Claude API error: ${response.statusText}`);\n      return [];\n    }\n\n    const data = (await response.json()) as {\n      data?: Array<{ id: string; display_name?: string }>;\n    };\n\n    if (!data.data || data.data.length === 0) {\n      return [];\n    }\n\n    const models = data.data\n      .filter((m) => m.id.includes('claude'))\n      .map((m) => ({\n        value: m.id,\n        label: m.display_name || m.id,\n      }));\n\n    return models;\n  } catch (err) {\n    console.warn('Failed to query Claude models:', err);\n    return [];\n  }\n}\n\n/**\n * Query OpenAI API for available models (Codex)\n */\nasync function getCodexModels(): Promise<ModelOption[]> {\n  try {\n    const apiKey=[REDACTED]\n    if (!apiKey) {\n      return [];\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 5000);\n\n    const response = await fetch('https://api.openai.com/v1/models', {\n      headers: {\n        Authorization: `Bearer ${apiKey}`,\n      },\n      signal: controller.signal,\n    });\n    clearTimeout(timeoutId);\n\n    if (!response.ok) {\n      console.warn(`OpenAI API error: ${response.statusText}`);\n      return [];\n    }\n\n    const data = (await response.json()) as {\n      data?: Array<{ id: string }>;\n    };\n\n    if (!data.data || data.data.length === 0) {\n      return [];\n    }\n\n    const models = data.data\n      .filter((m) => m.id.includes('code') || m.id.includes('davinci'))\n      .map((m) => ({\n        value: m.id,\n        label: m.id,\n      }));\n\n    return models;\n  } catch (err) {\n    console.warn('Failed to query OpenAI models:', err);\n    return [];\n  }\n}\n\n/**\n * Query Google AI API for available models (Gemini)\n */\nasync function getGeminiModels(): Promise<ModelOption[]> {\n  try {\n    const apiKey=[REDACTED]\n    if (!apiKey) {\n      return [];\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 5000);\n\n    const response = await fetch(\n      `https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`,\n      { signal: controller.signal }\n    );\n    clearTimeout(timeoutId);\n\n    if (!response.ok) {\n      console.warn(`Google AI API error: ${response.statusText}`);\n      return [];\n    }\n\n    const data = (await response.json()) as {\n      models?: Array<{ name: string; displayName?: string }>;\n    };\n\n    if (!data.models || data.models.length === 0) {\n      return [];\n    }\n\n    const models = data.models\n      .filter((m) => m.name.includes('gemini'))\n      .map((m) => ({\n        value: m.name.replace('models/', ''),\n        label: m.displayName || m.name,\n      }));\n\n    return models;\n  } catch (err) {\n    console.warn('Failed to query Gemini models:', err);\n    return [];\n  }\n}\n\n/**\n * Get default/static models for providers\n */\nfunction getDefaultModels(provider: string): ModelOption[] {\n  const defaults: Record<string, ModelOption[]> = {\n    claude: [\n      { value: 'claude-opus-4-5', label: 'Claude Opus 4.5' },\n      { value: 'claude-sonnet-4-20250514', label: 'Claude Sonnet 4' },\n      { value: 'claude-haiku-4-5-20251001', label: 'Claude Haiku 4.5' },\n    ],\n    codex: [\n      { value: 'code-davinci-003', label: 'Code Davinci 003' },\n      { value: 'code-davinci-002', label: 'Code Davinci 002' },\n    ],\n    gemini: [\n      { value: 'gemini-2.0-flash', label: 'Gemini 2.0 Flash' },\n      { value: 'gemini-1.5-pro', label: 'Gemini 1.5 Pro' },\n      { value: 'gemini-1.5-flash', label: 'Gemini 1.5 Flash' },\n    ],\n  };\n\n  return defaults[provider] || [];\n}\n\nexport async function modelsRoutes(fastify: FastifyInstance) {\n  /**\n   * Get available models for a specific provider\n   * GET /api/models/:provider\n   */\n  fastify.get('/api/models/:provider', async (request, reply) => {\n    const { provider } = request.params as { provider: string };\n\n    let models: ModelOption[] = [];\n    let available = false;\n    let error: string | undefined;\n\n    switch (provider.toLowerCase()) {\n      case 'claude':\n        models = await getClaudeModels();\n        available = models.length > 0;\n        if (!available) {\n          models = getDefaultModels('claude');\n          error = 'ANTHROPIC_API_KEY not set or API unreachable, showing default models';\n        }\n        break;\n\n      case 'codex':\n        models = await getCodexModels();\n        available = models.length > 0;\n        if (!available) {\n          models = getDefaultModels('codex');\n          error = 'OPENAI_API_KEY not set or API unreachable, showing default models';\n        }\n        break;\n\n      case 'gemini':\n        models = await getGeminiModels();\n        available = models.length > 0;\n        if (!available) {\n          models = getDefaultModels('gemini');\n          error = 'GOOGLE_API_KEY not set or API unreachable, showing default models';\n        }\n        break;\n\n      default:\n        return reply.code(400).send({\n          error: `Unknown provider: ${provider}. Supported: ollama, claude, codex, gemini`,\n        });\n    }\n\n    const response: ModelsResponse = {\n      provider,\n      models,\n      available,\n      ...(error && { error }),\n    };\n\n    return response;\n  });\n\n  /**\n   * Get all available models from all providers\n   * GET /api/models\n   */\n  fastify.get('/api/models', async (request, reply) => {\n    const providers = ['claude', 'codex', 'gemini'];\n    const allModels: Record<string, ModelsResponse> = {};\n\n    for (const provider of providers) {\n      let models: ModelOption[] = [];\n      let available = false;\n      let error: string | undefined;\n\n      switch (provider) {\n        case 'claude':\n          models = await getClaudeModels();\n          available = models.length > 0;\n          if (!available) {\n            models = getDefaultModels('claude');\n            error = 'ANTHROPIC_API_KEY not set or API unreachable';\n          }\n          break;\n\n        case 'codex':\n          models = await getCodexModels();\n          available = models.length > 0;\n          if (!available) {\n            models = getDefaultModels('codex');\n            error = 'OPENAI_API_KEY not set or API unreachable';\n          }\n          break;\n\n        case 'gemini':\n          models = await getGeminiModels();\n          available = models.length > 0;\n          if (!available) {\n            models = getDefaultModels('gemini');\n            error = 'GOOGLE_API_KEY not set or API unreachable';\n          }\n          break;\n      }\n\n      allModels[provider] = {\n        provider,\n        models,\n        available,\n        ...(error && { error }),\n      };\n    }\n\n    return allModels;\n  });\n}\n",
  "redacted": true,
  "redaction_rules_version": 1,
  "output_digest_raw": "f437ecc3547d8733d2927b9d3e31ab05ee5ffeaed74d198cca72bba9b328cd69",
  "output_digest_redacted": "4839e7ef1900494a15f02eeaff0df210270d29a8ec37bf4bb486f153facc7e6c",
  "truncated": false,
  "byte_len": 7483,
  "line_count": 292
}