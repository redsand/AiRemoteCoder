{
  "schema_version": "tool_output@1",
  "created_at": "2026-01-29T01:20:58Z",
  "tool": "write_file",
  "agent_name": "CodeWriterAgent",
  "session_id": "c1f12b2bdc364b3bb59d6037af1556f0",
  "task_id": "58",
  "step_id": 58,
  "tool_args": {
    "path": "gateway/src/routes/auth.test.ts",
    "content": "import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport Fastify from 'fastify';\nimport { authRoutes } from './auth.js';\nimport argon2 from 'argon2';\nimport { authenticator } from 'otplib';\nimport { db } from '../services/database.js';\n\n// Mock dependencies\nvi.mock('argon2');\nvi.mock('otplib');\nvi.mock('../services/database.js');\n\ndescribe('Auth Routes', () => {\n  let fastify: any;\n\n  const mockUser = {\n    id: 'user-123',\n    username: 'testuser',\n    passwordHash: 'hashedpassword123',\n    email: 'test@example.com',\n    totpSecret: 'JBSWY3DPEHPK3PXP',\n    totpEnabled: true,\n    createdAt: new Date('2024-01-01'),\n    updatedAt: new Date('2024-01-01'),\n  };\n\n  const mockSession = {\n    id: 'session-123',\n    userId: 'user-123',\n    token: 'valid-jwt-token',\n    refreshToken: 'refresh-token-123',\n    expiresAt: new Date(Date.now() + 3600000), // 1 hour from now\n    createdAt: new Date(),\n    lastAccessedAt: new Date(),\n  };\n\n  beforeEach(async () => {\n    fastify = Fastify();\n    await fastify.register(require('@fastify/cookie'));\n    await fastify.register(authRoutes);\n\n    // Reset all mocks\n    vi.clearAllMocks();\n\n    // Setup default mock returns\n    vi.mocked(argon2.verify).mockResolvedValue(true);\n    vi.mocked(argon2.hash).mockResolvedValue('new-hashed-password');\n    vi.mocked(authenticator.check).mockReturnValue(true);\n    vi.mocked(authenticator.generateSecret).mockReturnValue('NEWSECRET123');\n  });\n\n  afterEach(async () => {\n    await fastify.close();\n  });\n\n  describe('POST /auth/login', () => {\n    it('should successfully login with valid credentials and TOTP', async () => {\n      vi.mocked(db.user.findUnique).mockResolvedValue(mockUser);\n      vi.mocked(db.session.create).mockResolvedValue(mockSession);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/login',\n        payload: {\n          username: 'testuser',\n          password: 'password123',\n          totpCode: '123456',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('token');\n      expect(body).toHaveProperty('refreshToken');\n      expect(body).toHaveProperty('user');\n      expect(body.user.username).toBe('testuser');\n      expect(db.session.create).toHaveBeenCalled();\n    });\n\n    it('should successfully login without TOTP when not enabled', async () => {\n      const userWithoutTotp = { ...mockUser, totpEnabled: false };\n      vi.mocked(db.user.findUnique).mockResolvedValue(userWithoutTotp);\n      vi.mocked(db.session.create).mockResolvedValue(mockSession);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/login',\n        payload: {\n          username: 'testuser',\n          password: 'password123',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('token');\n      expect(db.session.create).toHaveBeenCalled();\n    });\n\n    it('should fail login with invalid username', async () => {\n      vi.mocked(db.user.findUnique).mockResolvedValue(null);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/login',\n        payload: {\n          username: 'nonexistent',\n          password: 'password123',\n          totpCode: '123456',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('error', 'Invalid credentials');\n      expect(db.session.create).not.toHaveBeenCalled();\n    });\n\n    it('should fail login with invalid password', async () => {\n      vi.mocked(argon2.verify).mockResolvedValue(false);\n      vi.mocked(db.user.findUnique).mockResolvedValue(mockUser);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/login',\n        payload: {\n          username: 'testuser',\n          password: 'wrongpassword',\n          totpCode: '123456',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('error', 'Invalid credentials');\n      expect(db.session.create).not.toHaveBeenCalled();\n    });\n\n    it('should fail login with invalid TOTP code', async () => {\n      vi.mocked(db.user.findUnique).mockResolvedValue(mockUser);\n      vi.mocked(authenticator.check).mockReturnValue(false);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/login',\n        payload: {\n          username: 'testuser',\n          password: 'password123',\n          totpCode: '000000',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('error', 'Invalid TOTP code');\n      expect(db.session.create).not.toHaveBeenCalled();\n    });\n\n    it('should fail login with missing required fields', async () => {\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/login',\n        payload: {\n          username: 'testuser',\n          // password missing\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('error');\n    });\n\n    it('should handle database errors during login', async () => {\n      vi.mocked(db.user.findUnique).mockRejectedValue(new Error('Database error'));\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/login',\n        payload: {\n          username: 'testuser',\n          password: 'password123',\n          totpCode: '123456',\n        },\n      });\n\n      expect(response.statusCode).toBe(500);\n    });\n\n    it('should set session cookie on successful login', async () => {\n      vi.mocked(db.user.findUnique).mockResolvedValue(mockUser);\n      vi.mocked(db.session.create).mockResolvedValue(mockSession);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/login',\n        payload: {\n          username: 'testuser',\n          password: 'password123',\n          totpCode: '123456',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const cookies = response.cookies;\n      expect(cookies).toBeDefined();\n      expect(cookies.some((c: any) => c.name === 'sessionId')).toBe(true);\n    });\n  });\n\n  describe('POST /auth/logout', () => {\n    it('should successfully logout with valid session', async () => {\n      vi.mocked(db.session.findUnique).mockResolvedValue(mockSession);\n      vi.mocked(db.session.delete).mockResolvedValue(mockSession);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/logout',\n        cookies: {\n          sessionId: 'session-123',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('message', 'Logged out successfully');\n      expect(db.session.delete).toHaveBeenCalledWith({\n        where: { id: 'session-123' },\n      });\n    });\n\n    it('should fail logout with invalid session', async () => {\n      vi.mocked(db.session.findUnique).mockResolvedValue(null);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/logout',\n        cookies: {\n          sessionId: 'invalid-session',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('error', 'Invalid session');\n      expect(db.session.delete).not.toHaveBeenCalled();\n    });\n\n    it('should clear session cookie on logout', async () => {\n      vi.mocked(db.session.findUnique).mockResolvedValue(mockSession);\n      vi.mocked(db.session.delete).mockResolvedValue(mockSession);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/logout',\n        cookies: {\n          sessionId: 'session-123',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const cookies = response.cookies;\n      expect(cookies).toBeDefined();\n      const sessionCookie = cookies.find((c: any) => c.name === 'sessionId');\n      expect(sessionCookie).toBeDefined();\n      expect(new Date(sessionCookie.expires) < new Date()).toBe(true);\n    });\n\n    it('should handle database errors during logout', async () => {\n      vi.mocked(db.session.findUnique).mockResolvedValue(mockSession);\n      vi.mocked(db.session.delete).mockRejectedValue(new Error('Database error'));\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/logout',\n        cookies: {\n          sessionId: 'session-123',\n        },\n      });\n\n      expect(response.statusCode).toBe(500);\n    });\n  });\n\n  describe('GET /auth/validate', () => {\n    it('should validate a valid token', async () => {\n      vi.mocked(db.session.findUnique).mockResolvedValue(mockSession);\n      vi.mocked(db.user.findUnique).mockResolvedValue(mockUser);\n\n      const response = await fastify.inject({\n        method: 'GET',\n        url: '/auth/validate',\n        headers: {\n          authorization: 'Bearer valid-jwt-token',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('valid', true);\n      expect(body).toHaveProperty('user');\n      expect(body.user.username).toBe('testuser');\n    });\n\n    it('should reject an invalid token', async () => {\n      vi.mocked(db.session.findUnique).mockResolvedValue(null);\n\n      const response = await fastify.inject({\n        method: 'GET',\n        url: '/auth/validate',\n        headers: {\n          authorization: 'Bearer invalid-token',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('valid', false);\n      expect(body).toHaveProperty('error');\n    });\n\n    it('should reject request without authorization header', async () => {\n      const response = await fastify.inject({\n        method: 'GET',\n        url: '/auth/validate',\n      });\n\n      expect(response.statusCode).toBe(401);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('valid', false);\n    });\n\n    it('should reject expired token', async () => {\n      const expiredSession = {\n        ...mockSession,\n        expiresAt: new Date(Date.now() - 3600000), // 1 hour ago\n      };\n      vi.mocked(db.session.findUnique).mockResolvedValue(expiredSession);\n\n      const response = await fastify.inject({\n        method: 'GET',\n        url: '/auth/validate',\n        headers: {\n          authorization: 'Bearer expired-token',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('valid', false);\n      expect(body.error).toContain('expired');\n    });\n\n    it('should handle malformed authorization header', async () => {\n      const response = await fastify.inject({\n        method: 'GET',\n        url: '/auth/validate',\n        headers: {\n          authorization: 'InvalidFormat token',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n  });\n\n  describe('POST /auth/refresh', () => {\n    it('should refresh token with valid refresh token', async () => {\n      const newSession = {\n        ...mockSession,\n        token: 'new-jwt-token',\n        refreshToken: 'new-refresh-token',\n      };\n      vi.mocked(db.session.findUnique).mockResolvedValue(mockSession);\n      vi.mocked(db.session.update).mockResolvedValue(newSession);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/refresh',\n        payload: {\n          refreshToken: 'refresh-token-123',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('token', 'new-jwt-token');\n      expect(body).toHaveProperty('refreshToken', 'new-refresh-token');\n    });\n\n    it('should fail refresh with invalid refresh token', async () => {\n      vi.mocked(db.session.findUnique).mockResolvedValue(null);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/refresh',\n        payload: {\n          refreshToken: 'invalid-refresh-token',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('error', 'Invalid refresh token');\n    });\n\n    it('should fail refresh with expired refresh token', async () => {\n      const expiredSession = {\n        ...mockSession,\n        expiresAt: new Date(Date.now() - 3600000),\n      };\n      vi.mocked(db.session.findUnique).mockResolvedValue(expiredSession);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/refresh',\n        payload: {\n          refreshToken: 'expired-refresh-token',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n      const body = JSON.parse(response.payload);\n      expect(body.error).toContain('expired');\n    });\n\n    it('should fail refresh without refresh token in payload', async () => {\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/refresh',\n        payload: {},\n      });\n\n      expect(response.statusCode).toBe(400);\n    });\n  });\n\n  describe('GET /auth/session', () => {\n    it('should retrieve current session information', async () => {\n      vi.mocked(db.session.findUnique).mockResolvedValue(mockSession);\n      vi.mocked(db.user.findUnique).mockResolvedValue(mockUser);\n\n      const response = await fastify.inject({\n        method: 'GET',\n        url: '/auth/session',\n        cookies: {\n          sessionId: 'session-123',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('session');\n      expect(body).toHaveProperty('user');\n      expect(body.user.username).toBe('testuser');\n      expect(body.session.id).toBe('session-123');\n    });\n\n    it('should return null for non-existent session', async () => {\n      vi.mocked(db.session.findUnique).mockResolvedValue(null);\n\n      const response = await fastify.inject({\n        method: 'GET',\n        url: '/auth/session',\n        cookies: {\n          sessionId: 'non-existent',\n        },\n      });\n\n      expect(response.statusCode).toBe(404);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('error', 'Session not found');\n    });\n\n    it('should update last accessed timestamp on session retrieval', async () => {\n      vi.mocked(db.session.findUnique).mockResolvedValue(mockSession);\n      vi.mocked(db.user.findUnique).mockResolvedValue(mockUser);\n      vi.mocked(db.session.update).mockResolvedValue({\n        ...mockSession,\n        lastAccessedAt: new Date(),\n      });\n\n      await fastify.inject({\n        method: 'GET',\n        url: '/auth/session',\n        cookies: {\n          sessionId: 'session-123',\n        },\n      });\n\n      expect(db.session.update).toHaveBeenCalled();\n      const updateCall = vi.mocked(db.session.update).mock.calls[0];\n      expect(updateCall[0].data).toHaveProperty('lastAccessedAt');\n    });\n  });\n\n  describe('DELETE /auth/session', () => {\n    it('should delete current session', async () => {\n      vi.mocked(db.session.findUnique).mockResolvedValue(mockSession);\n      vi.mocked(db.session.delete).mockResolvedValue(mockSession);\n\n      const response = await fastify.inject({\n        method: 'DELETE',\n        url: '/auth/session',\n        cookies: {\n          sessionId: 'session-123',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('message', 'Session deleted');\n      expect(db.session.delete).toHaveBeenCalledWith({\n        where: { id: 'session-123' },\n      });\n    });\n\n    it('should return 404 for non-existent session', async () => {\n      vi.mocked(db.session.findUnique).mockResolvedValue(null);\n\n      const response = await fastify.inject({\n        method: 'DELETE',\n        url: '/auth/session',\n        cookies: {\n          sessionId: 'non-existent',\n        },\n      });\n\n      expect(response.statusCode).toBe(404);\n    });\n  });\n\n  describe('GET /auth/sessions', () => {\n    const mockSessions = [\n      mockSession,\n      {\n        ...mockSession,\n        id: 'session-456',\n        token: 'another-token',\n      },\n    ];\n\n    it('should retrieve all sessions for user', async () => {\n      vi.mocked(db.session.findMany).mockResolvedValue(mockSessions);\n      vi.mocked(db.user.findUnique).mockResolvedValue(mockUser);\n\n      const response = await fastify.inject({\n        method: 'GET',\n        url: '/auth/sessions',\n        headers: {\n          authorization: 'Bearer valid-jwt-token',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('sessions');\n      expect(Array.isArray(body.sessions)).toBe(true);\n      expect(body.sessions.length).toBe(2);\n    });\n\n    it('should return empty array for user with no sessions', async () => {\n      vi.mocked(db.session.findMany).mockResolvedValue([]);\n\n      const response = await fastify.inject({\n        method: 'GET',\n        url: '/auth/sessions',\n        headers: {\n          authorization: 'Bearer valid-token',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.payload);\n      expect(body.sessions).toEqual([]);\n    });\n\n    it('should handle database errors when retrieving sessions', async () => {\n      vi.mocked(db.session.findMany).mockRejectedValue(new Error('Database error'));\n\n      const response = await fastify.inject({\n        method: 'GET',\n        url: '/auth/sessions',\n        headers: {\n          authorization: 'Bearer valid-token',\n        },\n      });\n\n      expect(response.statusCode).toBe(500);\n    });\n  });\n\n  describe('DELETE /auth/sessions/:id', () => {\n    it('should delete specific session', async () => {\n      vi.mocked(db.session.findUnique).mockResolvedValue(mockSession);\n      vi.mocked(db.session.delete).mockResolvedValue(mockSession);\n\n      const response = await fastify.inject({\n        method: 'DELETE',\n        url: '/auth/sessions/session-456',\n        headers: {\n          authorization: 'Bearer valid-token',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      expect(db.session.delete).toHaveBeenCalledWith({\n        where: { id: 'session-456' },\n      });\n    });\n\n    it('should return 404 for non-existent session', async () => {\n      vi.mocked(db.session.findUnique).mockResolvedValue(null);\n\n      const response = await fastify.inject({\n        method: 'DELETE',\n        url: '/auth/sessions/non-existent',\n        headers: {\n          authorization: 'Bearer valid-token',\n        },\n      });\n\n      expect(response.statusCode).toBe(404);\n    });\n\n    it('should prevent deleting other users sessions', async () => {\n      const otherUserSession = {\n        ...mockSession,\n        userId: 'other-user-456',\n      };\n      vi.mocked(db.session.findUnique).mockResolvedValue(otherUserSession);\n\n      const response = await fastify.inject({\n        method: 'DELETE',\n        url: '/auth/sessions/session-456',\n        headers: {\n          authorization: 'Bearer user-123-token',\n        },\n      });\n\n      expect(response.statusCode).toBe(403);\n      expect(db.session.delete).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('POST /auth/register', () => {\n    it('should successfully register a new user', async () => {\n      const newUser = {\n        id: 'user-456',\n        username: 'newuser',\n        email: 'newuser@example.com',\n        passwordHash: 'hashed-password',\n        totpEnabled: false,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n\n      vi.mocked(db.user.findUnique).mockResolvedValue(null);\n      vi.mocked(db.user.create).mockResolvedValue(newUser);\n      vi.mocked(db.session.create).mockResolvedValue(mockSession);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/register',\n        payload: {\n          username: 'newuser',\n          email: 'newuser@example.com',\n          password: 'securepassword123',\n        },\n      });\n\n      expect(response.statusCode).toBe(201);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('user');\n      expect(body).toHaveProperty('token');\n      expect(body.user.username).toBe('newuser');\n      expect(argon2.hash).toHaveBeenCalledWith('securepassword123');\n      expect(db.user.create).toHaveBeenCalled();\n    });\n\n    it('should fail registration with duplicate username', async () => {\n      vi.mocked(db.user.findUnique).mockResolvedValue(mockUser);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/register',\n        payload: {\n          username: 'testuser',\n          email: 'different@example.com',\n          password: 'password123',\n        },\n      });\n\n      expect(response.statusCode).toBe(409);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('error');\n      expect(db.user.create).not.toHaveBeenCalled();\n    });\n\n    it('should fail registration with duplicate email', async () => {\n      vi.mocked(db.user.findUnique)\n        .mockResolvedValueOnce(null) // username check\n        .mockResolvedValueOnce(mockUser); // email check\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/register',\n        payload: {\n          username: 'newuser',\n          email: 'test@example.com',\n          password: 'password123',\n        },\n      });\n\n      expect(response.statusCode).toBe(409);\n      expect(db.user.create).not.toHaveBeenCalled();\n    });\n\n    it('should validate password strength', async () => {\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/register',\n        payload: {\n          username: 'newuser',\n          email: 'newuser@example.com',\n          password: 'weak', // Too short\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('error');\n    });\n\n    it('should require all registration fields', async () => {\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/register',\n        payload: {\n          username: 'newuser',\n          // email missing\n          password: 'password123',\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n    });\n  });\n\n  describe('POST /auth/totp/enable', () => {\n    it('should generate TOTP secret for user', async () => {\n      vi.mocked(db.user.findUnique).mockResolvedValue(mockUser);\n      vi.mocked(db.user.update).mockResolvedValue({\n        ...mockUser,\n        totpSecret: 'NEWSECRET123',\n      });\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/totp/enable',\n        headers: {\n          authorization: 'Bearer valid-token',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('secret');\n      expect(body).toHaveProperty('qrCode');\n      expect(authenticator.generateSecret).toHaveBeenCalled();\n    });\n\n    it('should fail if TOTP already enabled', async () => {\n      vi.mocked(db.user.findUnique).mockResolvedValue({\n        ...mockUser,\n        totpEnabled: true,\n      });\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/totp/enable',\n        headers: {\n          authorization: 'Bearer valid-token',\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n      const body = JSON.parse(response.payload);\n      expect(body.error).toContain('already enabled');\n    });\n  });\n\n  describe('POST /auth/totp/verify', () => {\n    it('should verify and enable TOTP with valid code', async () => {\n      vi.mocked(db.user.findUnique).mockResolvedValue({\n        ...mockUser,\n        totpEnabled: false,\n        totpSecret: 'JBSWY3DPEHPK3PXP',\n      });\n      vi.mocked(authenticator.check).mockReturnValue(true);\n      vi.mocked(db.user.update).mockResolvedValue({\n        ...mockUser,\n        totpEnabled: true,\n      });\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/totp/verify',\n        headers: {\n          authorization: 'Bearer valid-token',\n        },\n        payload: {\n          code: '123456',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('message', 'TOTP enabled successfully');\n      expect(authenticator.check).toHaveBeenCalledWith('123456', 'JBSWY3DPEHPK3PXP');\n    });\n\n    it('should fail verification with invalid code', async () => {\n      vi.mocked(db.user.findUnique).mockResolvedValue(mockUser);\n      vi.mocked(authenticator.check).mockReturnValue(false);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/totp/verify',\n        headers: {\n          authorization: 'Bearer valid-token',\n        },\n        payload: {\n          code: '000000',\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('error', 'Invalid TOTP code');\n    });\n  });\n\n  describe('POST /auth/totp/disable', () => {\n    it('should disable TOTP for user', async () => {\n      vi.mocked(db.user.findUnique).mockResolvedValue(mockUser);\n      vi.mocked(db.user.update).mockResolvedValue({\n        ...mockUser,\n        totpEnabled: false,\n        totpSecret: null,\n      });\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/totp/disable',\n        headers: {\n          authorization: 'Bearer valid-token',\n        },\n        payload: {\n          password: 'password123',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('message', 'TOTP disabled successfully');\n    });\n\n    it('should require password to disable TOTP', async () => {\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/totp/disable',\n        headers: {\n          authorization: 'Bearer valid-token',\n        },\n        payload: {},\n      });\n\n      expect(response.statusCode).toBe(400);\n    });\n\n    it('should verify password before disabling TOTP', async () => {\n      vi.mocked(db.user.findUnique).mockResolvedValue(mockUser);\n      vi.mocked(argon2.verify).mockResolvedValue(false);\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/totp/disable',\n        headers: {\n          authorization: 'Bearer valid-token',\n        },\n        payload: {\n          password: 'wrongpassword',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n      expect(db.user.update).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('Session Cleanup', () => {\n    it('should clean up expired sessions', async () => {\n      const expiredSession = {\n        ...mockSession,\n        id: 'expired-123',\n        expiresAt: new Date(Date.now() - 3600000),\n      };\n\n      vi.mocked(db.session.deleteMany).mockResolvedValue({ count: 1 });\n\n      const response = await fastify.inject({\n        method: 'POST',\n        url: '/auth/cleanup',\n        headers: {\n          authorization: 'Bearer admin-token',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.payload);\n      expect(body).toHaveProperty('deletedCount');\n    });\n  });\n});"
  },
  "tool_args_digest": "e2ba9050794272b8fcc4932b54cfb1e3e0b6d1ab2fed1a378a7fa647ccf07a0e",
  "content_type": "text/plain",
  "output": "{\"wrote\": \"gateway\\\\src\\\\routes\\\\auth.test.ts\", \"bytes\": 28012, \"path_abs\": \"C:\\\\Users\\\\TimShelton\\\\source\\\\repos\\\\AiRemoteCoder\\\\gateway\\\\src\\\\routes\\\\auth.test.ts\", \"path_rel\": \"gateway/src/routes/auth.test.ts\"}",
  "redacted": false,
  "redaction_rules_version": 1,
  "output_digest_raw": "100a1198ad424c76dddd9d46c7c75b6f1d6a919bf8e06aa006960e1cd15ea6b4",
  "output_digest_redacted": "83645356f6a955b6cebde6dfee2f03c107d0197674ed64f90057f45bc752809d",
  "truncated": false,
  "byte_len": 213,
  "line_count": 1
}