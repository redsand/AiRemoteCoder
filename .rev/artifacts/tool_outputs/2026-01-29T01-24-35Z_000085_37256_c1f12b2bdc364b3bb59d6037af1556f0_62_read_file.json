{
  "schema_version": "tool_output@1",
  "created_at": "2026-01-29T01:24:35Z",
  "tool": "read_file",
  "agent_name": "ResearchAgent",
  "session_id": "c1f12b2bdc364b3bb59d6037af1556f0",
  "task_id": "62",
  "step_id": 62,
  "tool_args": {
    "path": "gateway/src/middleware/auth.ts"
  },
  "tool_args_digest": "43edbc992f1acb4f3d7e6bd5f319f1200da8ac20e1fa9b6b727431ba774b760b",
  "content_type": "text/plain",
  "output": "import type { FastifyRequest, FastifyReply, FastifyInstance } from 'fastify';\nimport { db } from '../services/database.js';\nimport { config } from '../config.js';\nimport { verifySignature, hashBody, isTimestampValid } from '../utils/crypto.js';\n\nexport interface AuthenticatedRequest extends FastifyRequest {\n  user?: {\n    id: string;\n    username: string;\n    role: 'admin' | 'operator' | 'viewer';\n    source: 'cloudflare' | 'session' | 'wrapper';\n  };\n  runAuth?: {\n    runId: string;\n    capabilityToken: string;\n  };\n}\n\n/**\n * Wrapper (agent) authentication middleware\n * Uses HMAC signature with replay protection\n */\nexport async function wrapperAuth(\n  request: AuthenticatedRequest,\n  reply: FastifyReply\n): Promise<void> {\n  const signature = request.headers['x-signature'] as string;\n  const timestamp = parseInt(request.headers['x-timestamp'] as string, 10);\n  const nonce = request.headers['x-nonce'] as string;\n  const runId = request.headers['x-run-id'] as string;\n  const capabilityToken = request.headers['x-capability-token'] as string;\n\n  // Validate required headers\n  if (!signature || !timestamp || !nonce) {\n    reply.code(401).send({ error: 'Missing authentication headers' });\n    return;\n  }\n\n  // Check timestamp validity (clock skew)\n  if (!isTimestampValid(timestamp)) {\n    reply.code(401).send({ error: 'Request timestamp out of allowed range' });\n    return;\n  }\n\n  // Check nonce for replay protection\n  const existingNonce = db.prepare('SELECT nonce FROM nonces WHERE nonce = ?').get(nonce);\n  if (existingNonce) {\n    reply.code(401).send({ error: 'Nonce already used (replay attack detected)' });\n    return;\n  }\n\n  // Calculate body hash\n  const rawBody = (request as any).rawBody || '';\n  const bodyHash = hashBody(rawBody);\n\n  // Verify signature\n  const isValid = verifySignature(signature, {\n    method: request.method,\n    path: request.url.split('?')[0],\n    bodyHash,\n    timestamp,\n    nonce,\n    runId,\n    capabilityToken\n  });\n\n  if (!isValid) {\n    reply.code(401).send({ error: 'Invalid signature' });\n    return;\n  }\n\n  // Verify capability token if runId provided\n  if (runId && capabilityToken) {\n    const run = db.prepare('SELECT capability_token FROM runs WHERE id = ?').get(runId) as any;\n    if (!run || run.capability_token !== capabilityToken) {\n      reply.code(403).send({ error: 'Invalid capability token for run' });\n      return;\n    }\n    request.runAuth = { runId, capabilityToken };\n  }\n\n  // Store nonce to prevent replay\n  db.prepare('INSERT INTO nonces (nonce) VALUES (?)').run(nonce);\n\n  request.user = {\n    id: 'wrapper',\n    username: 'wrapper',\n    role: 'operator',\n    source: 'wrapper'\n  };\n}\n\n/**\n * UI authentication middleware\n * Supports Cloudflare Access and local session auth\n */\nexport async function uiAuth(\n  request: AuthenticatedRequest,\n  reply: FastifyReply\n): Promise<void> {\n  // Check Cloudflare Access headers first\n  const cfEmail = request.headers['cf-access-authenticated-user-email'] as string;\n  const cfJwt = request.headers['cf-access-jwt-assertion'] as string;\n\n  if (config.cfAccessTeam && cfEmail && cfJwt) {\n    // In production, verify the JWT against Cloudflare's keys\n    // For now, trust the headers if CF team is configured\n    request.user = {\n      id: `cf:${cfEmail}`,\n      username: cfEmail,\n      role: 'operator', // Could be configured per-user\n      source: 'cloudflare'\n    };\n    return;\n  }\n\n  // Fall back to session auth\n  const sessionToken = request.cookies?.session ||\n    (request.headers.authorization?.startsWith('Bearer ')\n      ? request.headers.authorization.slice(7)\n      : null);\n\n  if (!sessionToken) {\n    reply.code(401).send({ error: 'Authentication required' });\n    return;\n  }\n\n  const session = db.prepare(`\n    SELECT s.*, u.username, u.role\n    FROM sessions s\n    JOIN users u ON s.user_id = u.id\n    WHERE s.id = ? AND s.expires_at > unixepoch()\n  `).get(sessionToken) as any;\n\n  if (!session) {\n    reply.code(401).send({ error: 'Invalid or expired session' });\n    return;\n  }\n\n  request.user = {\n    id: session.user_id,\n    username: session.username,\n    role: session.role,\n    source: 'session'\n  };\n}\n\n/**\n * Require specific role\n */\nexport function requireRole(...roles: string[]) {\n  return async (request: AuthenticatedRequest, reply: FastifyReply) => {\n    if (!request.user) {\n      reply.code(401).send({ error: 'Authentication required' });\n      return;\n    }\n\n    if (!roles.includes(request.user.role)) {\n      reply.code(403).send({ error: 'Insufficient permissions' });\n      return;\n    }\n  };\n}\n\n/**\n * Audit log helper\n */\nexport function logAudit(\n  userId: string | undefined,\n  action: string,\n  targetType?: string,\n  targetId?: string,\n  details?: object,\n  ipAddress?: string\n): void {\n  db.prepare(`\n    INSERT INTO audit_log (user_id, action, target_type, target_id, details, ip_address)\n    VALUES (?, ?, ?, ?, ?, ?)\n  `).run(\n    userId || null,\n    action,\n    targetType || null,\n    targetId || null,\n    details ? JSON.stringify(details) : null,\n    ipAddress || null\n  );\n}\n\n/**\n * Plugin to capture raw body for signature verification\n */\nexport function rawBodyPlugin(fastify: FastifyInstance) {\n  fastify.addContentTypeParser(\n    'application/json',\n    { parseAs: 'string' },\n    (req, body, done) => {\n      (req as any).rawBody = body;\n      try {\n        done(null, body ? JSON.parse(body as string) : {});\n      } catch (err) {\n        done(err as Error, undefined);\n      }\n    }\n  );\n}\n",
  "redacted": false,
  "redaction_rules_version": 1,
  "output_digest_raw": "9c8baa3f5dd46ca7db861cee327564477e5e2590192830bb12aaffb668136204",
  "output_digest_redacted": "00380005282d3d1088987ff20e3feebe2587c249de8effb7a7f746e2777b44b5",
  "truncated": false,
  "byte_len": 5489,
  "line_count": 205
}