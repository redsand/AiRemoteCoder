{
  "schema_version": "tool_output@1",
  "created_at": "2026-01-29T01:25:47Z",
  "tool": "write_file",
  "agent_name": "CodeWriterAgent",
  "session_id": "c1f12b2bdc364b3bb59d6037af1556f0",
  "task_id": "63",
  "step_id": 63,
  "tool_args": {
    "path": "gateway/src/middleware/auth.test.ts",
    "content": "import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport type { FastifyRequest, FastifyReply } from 'fastify';\nimport crypto from 'crypto';\n\n// Mock config before imports\nvi.mock('../config.js', () => ({\n  config: {\n    hmacSecret: 'test-secret-key-that-is-long-enough-for-hmac',\n    clockSkewSeconds: 300,\n    nonceExpirySeconds: 600,\n    cfAccessTeam: 'test-team',\n    cfAccessAudience: 'https://example.com',\n    tlsEnabled: false\n  }\n}));\n\n// Mock database\nconst mockPreparedStmts = {\n  getUserBySession: vi.fn(),\n  getUserByWrapperId: vi.fn(),\n  getUserByCfId: vi.fn(),\n  createSession: vi.fn(),\n  deleteSession: vi.fn(),\n  getNonce: vi.fn(),\n  createNonce: vi.fn(),\n  deleteNonce: vi.fn()\n};\n\nvi.mock('../db.js', () => ({\n  db: {\n    prepare: vi.fn(() => mockPreparedStmts)\n  }\n}));\n\n// Import after mocks\nimport * as authMiddleware from './auth.js';\nimport { config } from '../config.js';\n\ndescribe('Authentication Middleware', () => {\n  let mockRequest: Partial<FastifyRequest>;\n  let mockReply: Partial<FastifyReply>;\n\n  beforeEach(() => {\n    mockRequest = {\n      headers: {},\n      cookies: {},\n      body: {},\n      log: {\n        info: vi.fn(),\n        warn: vi.fn(),\n        error: vi.fn()\n      }\n    } as Partial<FastifyRequest>;\n\n    mockReply = {\n      status: vi.fn().mockReturnThis(),\n      send: vi.fn().mockReturnThis(),\n      code: vi.fn().mockReturnThis(),\n      header: vi.fn().mockReturnThis()\n    } as Partial<FastifyReply>;\n\n    vi.clearAllMocks();\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  describe('Wrapper Authentication', () => {\n    it('should authenticate valid wrapper token', async () => {\n      const wrapperId = 'wrapper-123';\n      const timestamp = Date.now();\n      const signature = crypto\n        .createHmac('sha256', config.hmacSecret)\n        .update(`${wrapperId}:${timestamp}`)\n        .digest('hex');\n\n      mockRequest.headers = {\n        'x-wrapper-id': wrapperId,\n        'x-wrapper-signature': signature,\n        'x-wrapper-timestamp': timestamp.toString()\n      };\n\n      mockPreparedStmts.getUserByWrapperId.mockResolvedValue({\n        id: 'user-1',\n        wrapper_id: wrapperId,\n        email: 'wrapper@example.com'\n      });\n\n      const result = await authMiddleware.authenticateWrapper(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(true);\n      expect(mockRequest.user).toBeDefined();\n      expect(mockRequest.user.id).toBe('user-1');\n    });\n\n    it('should reject wrapper auth with missing headers', async () => {\n      mockRequest.headers = {};\n\n      const result = await authMiddleware.authenticateWrapper(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n      expect(mockReply.send).toHaveBeenCalledWith(\n        expect.objectContaining({ error: 'Missing wrapper authentication headers' })\n      );\n    });\n\n    it('should reject wrapper auth with invalid signature', async () => {\n      mockRequest.headers = {\n        'x-wrapper-id': 'wrapper-123',\n        'x-wrapper-signature': 'invalid-signature',\n        'x-wrapper-timestamp': Date.now().toString()\n      };\n\n      const result = await authMiddleware.authenticateWrapper(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n      expect(mockReply.send).toHaveBeenCalledWith(\n        expect.objectContaining({ error: 'Invalid wrapper signature' })\n      );\n    });\n\n    it('should reject wrapper auth with expired timestamp', async () => {\n      const wrapperId = 'wrapper-123';\n      const expiredTimestamp = Date.now() - (config.clockSkewSeconds + 100) * 1000;\n      const signature = crypto\n        .createHmac('sha256', config.hmacSecret)\n        .update(`${wrapperId}:${expiredTimestamp}`)\n        .digest('hex');\n\n      mockRequest.headers = {\n        'x-wrapper-id': wrapperId,\n        'x-wrapper-signature': signature,\n        'x-wrapper-timestamp': expiredTimestamp.toString()\n      };\n\n      const result = await authMiddleware.authenticateWrapper(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n      expect(mockReply.send).toHaveBeenCalledWith(\n        expect.objectContaining({ error: 'Timestamp too old' })\n      );\n    });\n\n    it('should reject wrapper auth when user not found', async () => {\n      const wrapperId = 'wrapper-123';\n      const timestamp = Date.now();\n      const signature = crypto\n        .createHmac('sha256', config.hmacSecret)\n        .update(`${wrapperId}:${timestamp}`)\n        .digest('hex');\n\n      mockRequest.headers = {\n        'x-wrapper-id': wrapperId,\n        'x-wrapper-signature': signature,\n        'x-wrapper-timestamp': timestamp.toString()\n      };\n\n      mockPreparedStmts.getUserByWrapperId.mockResolvedValue(undefined);\n\n      const result = await authMiddleware.authenticateWrapper(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n      expect(mockReply.send).toHaveBeenCalledWith(\n        expect.objectContaining({ error: 'Wrapper user not found' })\n      );\n    });\n  });\n\n  describe('Session Authentication', () => {\n    it('should authenticate valid session cookie', async () => {\n      const sessionId = crypto.randomUUID();\n      mockRequest.cookies = {\n        session: sessionId\n      };\n\n      mockPreparedStmts.getUserBySession.mockResolvedValue({\n        id: 'user-1',\n        email: 'user@example.com',\n        session_id: sessionId\n      });\n\n      const result = await authMiddleware.authenticateSession(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(true);\n      expect(mockRequest.user).toBeDefined();\n      expect(mockRequest.user.id).toBe('user-1');\n    });\n\n    it('should reject session auth with missing cookie', async () => {\n      mockRequest.cookies = {};\n\n      const result = await authMiddleware.authenticateSession(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n      expect(mockReply.send).toHaveBeenCalledWith(\n        expect.objectContaining({ error: 'No session cookie' })\n      );\n    });\n\n    it('should reject session auth with invalid session', async () => {\n      mockRequest.cookies = {\n        session: 'invalid-session-id'\n      };\n\n      mockPreparedStmts.getUserBySession.mockResolvedValue(undefined);\n\n      const result = await authMiddleware.authenticateSession(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n      expect(mockReply.send).toHaveBeenCalledWith(\n        expect.objectContaining({ error: 'Invalid session' })\n      );\n    });\n\n    it('should reject session auth with expired session', async () => {\n      const sessionId = crypto.randomUUID();\n      mockRequest.cookies = {\n        session: sessionId\n      };\n\n      mockPreparedStmts.getUserBySession.mockResolvedValue({\n        id: 'user-1',\n        email: 'user@example.com',\n        session_id: sessionId,\n        expires_at: new Date(Date.now() - 3600000) // Expired 1 hour ago\n      });\n\n      const result = await authMiddleware.authenticateSession(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n      expect(mockReply.send).toHaveBeenCalledWith(\n        expect.objectContaining({ error: 'Session expired' })\n      );\n    });\n\n    it('should handle database errors gracefully', async () => {\n      mockRequest.cookies = {\n        session: crypto.randomUUID()\n      };\n\n      mockPreparedStmts.getUserBySession.mockRejectedValue(new Error('Database error'));\n\n      const result = await authMiddleware.authenticateSession(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(500);\n    });\n  });\n\n  describe('Cloudflare Access Authentication', () => {\n    it('should authenticate valid Cloudflare Access JWT', async () => {\n      const cfId = 'cf-user-123';\n      const jwtPayload = {\n        aud: config.cfAccessAudience,\n        email: 'cf@example.com',\n        sub: cfId,\n        exp: Math.floor(Date.now() / 1000) + 3600\n      };\n\n      mockRequest.headers = {\n        'cf-access-jwt-assertion': btoa(JSON.stringify(jwtPayload))\n      };\n\n      mockPreparedStmts.getUserByCfId.mockResolvedValue({\n        id: 'user-1',\n        cf_id: cfId,\n        email: 'cf@example.com'\n      });\n\n      const result = await authMiddleware.authenticateCloudflare(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(true);\n      expect(mockRequest.user).toBeDefined();\n      expect(mockRequest.user.id).toBe('user-1');\n    });\n\n    it('should reject Cloudflare auth with missing JWT', async () => {\n      mockRequest.headers = {};\n\n      const result = await authMiddleware.authenticateCloudflare(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n      expect(mockReply.send).toHaveBeenCalledWith(\n        expect.objectContaining({ error: 'Missing Cloudflare Access JWT' })\n      );\n    });\n\n    it('should reject Cloudflare auth with invalid JWT format', async () => {\n      mockRequest.headers = {\n        'cf-access-jwt-assertion': 'invalid-jwt'\n      };\n\n      const result = await authMiddleware.authenticateCloudflare(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n      expect(mockReply.send).toHaveBeenCalledWith(\n        expect.objectContaining({ error: 'Invalid JWT format' })\n      );\n    });\n\n    it('should reject Cloudflare auth with wrong audience', async () => {\n      const jwtPayload = {\n        aud: 'https://wrong-audience.com',\n        email: 'cf@example.com',\n        sub: 'cf-user-123',\n        exp: Math.floor(Date.now() / 1000) + 3600\n      };\n\n      mockRequest.headers = {\n        'cf-access-jwt-assertion': btoa(JSON.stringify(jwtPayload))\n      };\n\n      const result = await authMiddleware.authenticateCloudflare(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n      expect(mockReply.send).toHaveBeenCalledWith(\n        expect.objectContaining({ error: 'Invalid JWT audience' })\n      );\n    });\n\n    it('should reject Cloudflare auth with expired JWT', async () => {\n      const jwtPayload = {\n        aud: config.cfAccessAudience,\n        email: 'cf@example.com',\n        sub: 'cf-user-123',\n        exp: Math.floor(Date.now() / 1000) - 3600\n      };\n\n      mockRequest.headers = {\n        'cf-access-jwt-assertion': btoa(JSON.stringify(jwtPayload))\n      };\n\n      const result = await authMiddleware.authenticateCloudflare(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n      expect(mockReply.send).toHaveBeenCalledWith(\n        expect.objectContaining({ error: 'JWT expired' })\n      );\n    });\n\n    it('should create new user on first Cloudflare login', async () => {\n      const cfId = 'cf-new-user';\n      const jwtPayload = {\n        aud: config.cfAccessAudience,\n        email: 'newuser@example.com',\n        sub: cfId,\n        exp: Math.floor(Date.now() / 1000) + 3600\n      };\n\n      mockRequest.headers = {\n        'cf-access-jwt-assertion': btoa(JSON.stringify(jwtPayload))\n      };\n\n      mockPreparedStmts.getUserByCfId.mockResolvedValue(undefined);\n      mockPreparedStmts.createSession.mockResolvedValue({ session_id: 'new-session' });\n\n      const result = await authMiddleware.authenticateCloudflare(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(true);\n      expect(mockPreparedStmts.createSession).toHaveBeenCalled();\n    });\n  });\n\n  describe('Signature Verification', () => {\n    it('should verify valid HMAC signature', async () => {\n      const payload = JSON.stringify({ action: 'test', data: 'sample' });\n      const signature = crypto\n        .createHmac('sha256', config.hmacSecret)\n        .update(payload)\n        .digest('hex');\n\n      mockRequest.headers = {\n        'x-signature': signature\n      };\n      mockRequest.body = JSON.parse(payload);\n\n      const result = await authMiddleware.verifySignature(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(true);\n    });\n\n    it('should reject invalid signature', async () => {\n      const payload = JSON.stringify({ action: 'test', data: 'sample' });\n      const invalidSignature = 'invalid-signature-here';\n\n      mockRequest.headers = {\n        'x-signature': invalidSignature\n      };\n      mockRequest.body = JSON.parse(payload);\n\n      const result = await authMiddleware.verifySignature(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n      expect(mockReply.send).toHaveBeenCalledWith(\n        expect.objectContaining({ error: 'Invalid signature' })\n      );\n    });\n\n    it('should reject missing signature', async () => {\n      mockRequest.headers = {};\n      mockRequest.body = { action: 'test' };\n\n      const result = await authMiddleware.verifySignature(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n      expect(mockReply.send).toHaveBeenCalledWith(\n        expect.objectContaining({ error: 'Missing signature' })\n      );\n    });\n\n    it('should handle signature with different hash algorithms', async () => {\n      const payload = 'test-payload';\n      \n      // Test SHA256\n      const sha256Sig = crypto\n        .createHmac('sha256', config.hmacSecret)\n        .update(payload)\n        .digest('hex');\n\n      mockRequest.headers = {\n        'x-signature': sha256Sig,\n        'x-signature-algo': 'sha256'\n      };\n      mockRequest.body = payload;\n\n      let result = await authMiddleware.verifySignature(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n      expect(result).toBe(true);\n\n      // Test SHA512\n      const sha512Sig = crypto\n        .createHmac('sha512', config.hmacSecret)\n        .update(payload)\n        .digest('hex');\n\n      mockRequest.headers = {\n        'x-signature': sha512Sig,\n        'x-signature-algo': 'sha512'\n      };\n\n      result = await authMiddleware.verifySignature(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n      expect(result).toBe(true);\n    });\n\n    it('should verify signature with timestamp and nonce', async () => {\n      const nonce = crypto.randomUUID();\n      const timestamp = Date.now();\n      const payload = JSON.stringify({ action: 'test' });\n      const dataToSign = `${nonce}:${timestamp}:${payload}`;\n      const signature = crypto\n        .createHmac('sha256', config.hmacSecret)\n        .update(dataToSign)\n        .digest('hex');\n\n      mockRequest.headers = {\n        'x-signature': signature,\n        'x-nonce': nonce,\n        'x-timestamp': timestamp.toString()\n      };\n      mockRequest.body = JSON.parse(payload);\n\n      mockPreparedStmts.getNonce.mockResolvedValue(undefined);\n      mockPreparedStmts.createNonce.mockResolvedValue(undefined);\n\n      const result = await authMiddleware.verifySignature(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(true);\n      expect(mockPreparedStmts.createNonce).toHaveBeenCalled();\n    });\n\n    it('should reject replayed nonce', async () => {\n      const nonce = crypto.randomUUID();\n      const timestamp = Date.now();\n      const payload = JSON.stringify({ action: 'test' });\n      const dataToSign = `${nonce}:${timestamp}:${payload}`;\n      const signature = crypto\n        .createHmac('sha256', config.hmacSecret)\n        .update(dataToSign)\n        .digest('hex');\n\n      mockRequest.headers = {\n        'x-signature': signature,\n        'x-nonce': nonce,\n        'x-timestamp': timestamp.toString()\n      };\n      mockRequest.body = JSON.parse(payload);\n\n      mockPreparedStmts.getNonce.mockResolvedValue({ nonce, created_at: new Date() });\n\n      const result = await authMiddleware.verifySignature(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n      expect(mockReply.send).toHaveBeenCalledWith(\n        expect.objectContaining({ error: 'Nonce already used' })\n      );\n    });\n\n    it('should reject expired timestamp in signature', async () => {\n      const nonce = crypto.randomUUID();\n      const expiredTimestamp = Date.now() - (config.clockSkewSeconds + 100) * 1000;\n      const payload = JSON.stringify({ action: 'test' });\n      const dataToSign = `${nonce}:${expiredTimestamp}:${payload}`;\n      const signature = crypto\n        .createHmac('sha256', config.hmacSecret)\n        .update(dataToSign)\n        .digest('hex');\n\n      mockRequest.headers = {\n        'x-signature': signature,\n        'x-nonce': nonce,\n        'x-timestamp': expiredTimestamp.toString()\n      };\n      mockRequest.body = JSON.parse(payload);\n\n      mockPreparedStmts.getNonce.mockResolvedValue(undefined);\n\n      const result = await authMiddleware.verifySignature(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n      expect(mockReply.send).toHaveBeenCalledWith(\n        expect.objectContaining({ error: 'Timestamp expired' })\n      );\n    });\n\n    it('should clean up expired nonces', async () => {\n      const nonce = crypto.randomUUID();\n      const timestamp = Date.now();\n      const payload = JSON.stringify({ action: 'test' });\n      const dataToSign = `${nonce}:${timestamp}:${payload}`;\n      const signature = crypto\n        .createHmac('sha256', config.hmacSecret)\n        .update(dataToSign)\n        .digest('hex');\n\n      mockRequest.headers = {\n        'x-signature': signature,\n        'x-nonce': nonce,\n        'x-timestamp': timestamp.toString()\n      };\n      mockRequest.body = JSON.parse(payload);\n\n      mockPreparedStmts.getNonce.mockResolvedValue(undefined);\n      mockPreparedStmts.deleteNonce.mockResolvedValue(undefined);\n      mockPreparedStmts.createNonce.mockResolvedValue(undefined);\n\n      await authMiddleware.verifySignature(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      // Should attempt to clean up old nonces\n      expect(mockPreparedStmts.deleteNonce).toHaveBeenCalled();\n    });\n  });\n\n  describe('Multi-Method Authentication', () => {\n    it('should try multiple auth methods in order', async () => {\n      // Set up session auth\n      const sessionId = crypto.randomUUID();\n      mockRequest.cookies = { session: sessionId };\n      mockPreparedStmts.getUserBySession.mockResolvedValue({\n        id: 'user-1',\n        email: 'user@example.com'\n      });\n\n      const result = await authMiddleware.authenticate(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(true);\n      expect(mockRequest.user).toBeDefined();\n    });\n\n    it('should fall through to next auth method if first fails', async () => {\n      // Session fails, wrapper succeeds\n      mockRequest.cookies = { session: 'invalid' };\n      mockPreparedStmts.getUserBySession.mockResolvedValue(undefined);\n\n      const wrapperId = 'wrapper-123';\n      const timestamp = Date.now();\n      const signature = crypto\n        .createHmac('sha256', config.hmacSecret)\n        .update(`${wrapperId}:${timestamp}`)\n        .digest('hex');\n\n      mockRequest.headers = {\n        'x-wrapper-id': wrapperId,\n        'x-wrapper-signature': signature,\n        'x-wrapper-timestamp': timestamp.toString()\n      };\n\n      mockPreparedStmts.getUserByWrapperId.mockResolvedValue({\n        id: 'user-1',\n        wrapper_id: wrapperId\n      });\n\n      const result = await authMiddleware.authenticate(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(true);\n    });\n\n    it('should fail when all auth methods fail', async () => {\n      mockRequest.cookies = {};\n      mockRequest.headers = {};\n      mockPreparedStmts.getUserBySession.mockResolvedValue(undefined);\n      mockPreparedStmts.getUserByWrapperId.mockResolvedValue(undefined);\n      mockPreparedStmts.getUserByCfId.mockResolvedValue(undefined);\n\n      const result = await authMiddleware.authenticate(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n    });\n\n    it('should skip signature verification for GET requests', async () => {\n      mockRequest.method = 'GET';\n      mockRequest.cookies = { session: 'valid-session' };\n      mockPreparedStmts.getUserBySession.mockResolvedValue({\n        id: 'user-1',\n        email: 'user@example.com'\n      });\n\n      const result = await authMiddleware.authenticate(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(true);\n    });\n\n    it('should require signature for POST requests', async () => {\n      mockRequest.method = 'POST';\n      mockRequest.cookies = { session: 'valid-session' };\n      mockRequest.headers = {};\n      mockRequest.body = { action: 'test' };\n      mockPreparedStmts.getUserBySession.mockResolvedValue({\n        id: 'user-1',\n        email: 'user@example.com'\n      });\n\n      const result = await authMiddleware.authenticate(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n    });\n  });\n\n  describe('Rate Limiting Integration', () => {\n    it('should track failed authentication attempts', async () => {\n      mockRequest.cookies = { session: 'invalid' };\n      mockRequest.ip = '192.168.1.1';\n      mockPreparedStmts.getUserBySession.mockResolvedValue(undefined);\n\n      for (let i = 0; i < 5; i++) {\n        await authMiddleware.authenticateSession(\n          mockRequest as FastifyRequest,\n          mockReply as FastifyReply\n        );\n      }\n\n      expect(mockReply.status).toHaveBeenCalledWith(401);\n    });\n\n    it('should lock out after too many failed attempts', async () => {\n      mockRequest.cookies = { session: 'invalid' };\n      mockRequest.ip = '192.168.1.1';\n      mockPreparedStmts.getUserBySession.mockResolvedValue(undefined);\n\n      // Simulate rate limit exceeded\n      const result = await authMiddleware.checkRateLimit(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(result).toBe(false);\n      expect(mockReply.status).toHaveBeenCalledWith(429);\n    });\n  });\n\n  describe('Security Headers', () => {\n    it('should add security headers after successful auth', async () => {\n      const sessionId = crypto.randomUUID();\n      mockRequest.cookies = { session: sessionId };\n      mockPreparedStmts.getUserBySession.mockResolvedValue({\n        id: 'user-1',\n        email: 'user@example.com'\n      });\n\n      await authMiddleware.authenticate(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(mockReply.header).toHaveBeenCalledWith(\n        'X-Content-Type-Options',\n        'nosniff'\n      );\n    });\n\n    it('should add CSRF token for state-changing requests', async () => {\n      mockRequest.method = 'POST';\n      mockRequest.cookies = { session: 'valid-session' };\n      mockRequest.headers = {\n        'x-signature': crypto\n          .createHmac('sha256', config.hmacSecret)\n          .update('{\"action\":\"test\"}')\n          .digest('hex')\n      };\n      mockRequest.body = { action: 'test' };\n      mockPreparedStmts.getUserBySession.mockResolvedValue({\n        id: 'user-1',\n        email: 'user@example.com'\n      });\n\n      await authMiddleware.authenticate(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(mockReply.header).toHaveBeenCalledWith(\n        'X-CSRF-Token',\n        expect.any(String)\n      );\n    });\n  });\n\n  describe('Token Refresh', () => {\n    it('should refresh expiring session', async () => {\n      const sessionId = crypto.randomUUID();\n      const expiringSession = {\n        id: 'user-1',\n        email: 'user@example.com',\n        session_id: sessionId,\n        expires_at: new Date(Date.now() + 300000) // Expires in 5 minutes\n      };\n\n      mockRequest.cookies = { session: sessionId };\n      mockPreparedStmts.getUserBySession.mockResolvedValue(expiringSession);\n      mockPreparedStmts.createSession.mockResolvedValue({\n        session_id: 'new-session-id'\n      });\n\n      await authMiddleware.authenticateSession(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(mockPreparedStmts.createSession).toHaveBeenCalled();\n      expect(mockReply.header).toHaveBeenCalledWith(\n        'Set-Cookie',\n        expect.stringContaining('new-session-id')\n      );\n    });\n\n    it('should not refresh fresh session', async () => {\n      const sessionId = crypto.randomUUID();\n      const freshSession = {\n        id: 'user-1',\n        email: 'user@example.com',\n        session_id: sessionId,\n        expires_at: new Date(Date.now() + 86400000) // Expires in 24 hours\n      };\n\n      mockRequest.cookies = { session: sessionId };\n      mockPreparedStmts.getUserBySession.mockResolvedValue(freshSession);\n\n      await authMiddleware.authenticateSession(\n        mockRequest as FastifyRequest,\n        mockReply as FastifyReply\n      );\n\n      expect(mockPreparedStmts.createSession).not.toHaveBeenCalled();\n    });\n  });\n});"
  },
  "tool_args_digest": "563ca3e2c5b651558df0bd67b18c30b369ef8029a8f5083cb2ceecd11b678946",
  "content_type": "text/plain",
  "output": "{\"wrote\": \"gateway\\\\src\\\\middleware\\\\auth.test.ts\", \"bytes\": 26790, \"path_abs\": \"C:\\\\Users\\\\TimShelton\\\\source\\\\repos\\\\AiRemoteCoder\\\\gateway\\\\src\\\\middleware\\\\auth.test.ts\", \"path_rel\": \"gateway/src/middleware/auth.test.ts\"}",
  "redacted": false,
  "redaction_rules_version": 1,
  "output_digest_raw": "06aa611d985e47135872f3b35884abb1578311b1d486eb06237f95fe2ac4244d",
  "output_digest_redacted": "2d0fb603135e858b7b35fd432365ebe17717ce7e6e20e5ad30c0639fe3c57da1",
  "truncated": false,
  "byte_len": 225,
  "line_count": 1
}